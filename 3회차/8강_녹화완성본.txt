이겸
안녕하세요, 여러분. 국립창원대학교 PRU 재직자 교육 과정에 오신 것을 환영합니다.
오늘은 외부 시스템 연동, 특히 API 기초에 대해 함께 살펴보겠습니다.
제조 현장에서 MES, ERP, PLM 같은 시스템들이 각각 따로 놀고 있다면 어떤 문제가 생길까요? 
바로 데이터 중복 입력, 정보 불일치, 그리고 엄청난 시간 낭비가 발생하죠. 이런 문제를 해결하는 핵심이 바로 API를 통한 시스템 연동입니다.

오늘 강의는 크게 세 부분으로 구성됩니다. 먼저 기초 및 배경에서 API의 기본 개념과 제조 IT 시스템의 역할을 정의하고, 연동 아키텍처를 살펴보겠습니다.
두 번째로 핵심 응용과 실습 파트에서는 실제 MES-ERP, MES-PLM 연동 사례를 보고, Python으로 API를 직접 호출해보는 실습을 진행할 예정입니다. 마지막으로 심화 확장 단계에서는 RPA와 에이아이 에이전트를 결합한 지능형 자동화 아키텍처까지 다뤄보겠습니다.
학습 목표는 명확합니다. 첫째, 제조 IT 시스템 간 데이터 연동 구조를 이해하는 것. 둘째, Python으로 실제 API 호출 역량을 확보하는 것. 셋째, 단순 반복을 넘어선 지능형 자동화 설계 감각을 익히는 것입니다.

자, 그럼 첫 번째 섹션으로 들어가겠습니다. API와 제조 IT 전경이라는 주제인데요, API가 정확히 무엇인지, 그리고 우리 제조 현장의 복잡한 IT 시스템들이 어떤 역할을 하는지 명확히 정리해보겠습니다.

API는 무엇일까요? 정의는 Application Programming Interface 죠. 쉽게 말하면 소프트웨어끼리 대화하는 방법을 정의한 규약입니다. 내부 구현은 복잡해도 외부에서는 정해진 방식으로만 사용할 수 있도록 추상화해서 제공하는 거죠.
API의 핵심 요소 다섯 가지를 볼까요? 첫째, 자원입니다. 주고받을 데이터 객체를 URI로 표현하죠. 둘째는 메서드, Get으로 조회하고 Post로 생성하는 것처럼 행위를 정의합니다.
셋째, 표현 Representation은 데이터 형식을 의미합니다. 데이터를 json이나 XML 같은 포맷으로 주고받죠.
넷째는 상태 코드로, 200 OK, 사공사 Not Found 같이 처리 결과를 나타냅니다.
마지막으로 Contract, 계약 즉 사용 규칙과 문서입니다. Swagger나 Open-API 같은 걸로 명세를 만들어요.
주요 통신 유형은 Rest가 가장 대중적이고, Soap는 보안성이 높고, G-RPC는 고성능 내부통신에 적합합니다. 비동기 메시징은 Kafka나 Rabbit-MQ 같은 메시지 큐를 사용하죠.

제조 IT의 핵심은 세 개의 축으로 이뤄져 있습니다. 바로 MES, ERP, PLM이죠.
MES는 Manufacturing Execution, 즉 생산 실행 시스템입니다. 공정을 제어하고, 설비 가동을 모니터링하고, 생산 실적을 집계하는 현장 중심 시스템이에요.
ERP는 Enterprise Resource Planning, 전사적 자원 관리죠. 재무, 회계, 인사, 구매, 영업까지 경영 관점의 통합 관리를 담당합니다.
PLM은 Product Lifecycle Management, 제품 수명주기 관리입니다. 기획부터 설계, BOM, 기술 문서, 설계 변경까지 엔지니어링 중심의 데이터를 관리하죠.
이 시스템들을 연동하면 어떤 효과가 있을까요? 업무 처리 시간을 30% 단축하고, 데이터 정확도를 99%까지 올릴 수 있고, 정보 사일로를 해소할 수 있습니다. 
이를 통해 업무 리드 타임이 줄어들고, 휴먼 에러가 제거되며 부서 간 장벽이 사라지게 되죠.

실제로 데이터가 어떻게 흐르는지 보겠습니다.
먼저 기준 정보 흐름부터 보면, ERP에서 PLM으로 자재 마스터와 BOM이 동기화되고, 설계 변경이 반영되죠.
다음으로 PLM에서 MES로는 도면과 작업표준서가 전달됩니다. E-BOM기반이 M-BOM기반으로 변환되는 거죠.
핵심 트랜잭션을 보면 더 명확해요. ERP에서 MES로 작업지시가 내려가고, MES에서 다시 실적이 올라옵니다. 자재 불출이 일어나면 재고가 자동으로 차감되고요.
PLM에서 설계 변경이 발생하면 E-BOM이 M-BOM으로 변환돼서 MES에 반영되는 구조입니다.

연동 방식에도 여러 패턴이 있습니다. 제조 시스템의 규모와 요구사항에 따라 적절한 전략을 선택해야 해요.
Direct Call은 시스템 간 1대1 직접 호출입니다. 가장 단순하지만 시스템이 많아지면 관리가 어려워지죠.
Hub & Spoke는 중앙허브인 ESB나 i-PaaS를 통해 중계하는 방식입니다. 표준화와 모니터링이 용이하죠.
Event Driven은 메시지 버스나 Kafka를 사용해서 이벤트 발생 시 비동기로 전파합니다. 시스템 간 결합도가 최소화돼요.
API Gateway는 단일 진입점으로 트래픽을 관리하면서 보안, 인증, 로깅을 통합할 수 있습니다.
마지막으로 Virtualization은 CDC나 뷰를 통해 데이터를 이동시키지 않고 통합 뷰만 제공하는 실시간 조회 중심 방식입니다.

레스트, Soap, G-RPC에 대한 프로토콜 비교를 해볼까요? 
레스트는 Representational State Transfer로, 웹 표준 HTTP를 그대로 활용하는 아키텍처 스타일입니다. json 포맷이어서 가볍고 읽기 쉽고, 캐시 친화적이며, 무상태성 덕분에 서버 확장이 용이해요. 공개 API나 웹, 모바일 서비스에 최적입니다.
Soap는 Simple Object Access Protocol, 즉 XML 기반의 엄격한 프로토콜이에요. WSDL로 서비스를 명세하고, 애씨드 트랜잭션과 WS-Security로 엔터프라이즈급 보안을 보장합니다. 금융권이나 대규모 엔터프라이즈에서 많이 쓰죠.
G-RPC는 Google이 만든 고성능 Remote Procedure Calls 프레임워크입니다. Protocol Buffers로 바이너리 직렬화를 하고, HTTP/two 기반으로 양방향 스트리밍을 지원합니다. IDL 하나로 다언어 클라이언트 코드를 자동 생성할 수 있어서 마이크로서비스나 실시간 통신에 적합합니다.

제조 현장 데이터는 기업의 핵심 자산입니다. 제로 트러스트 모델을 기반으로 모든 요청을 검증해야 해요.
API 보안의 세 가지 요소를 보겠습니다. 
첫째, 인증은 사용자의 신원을 확인하는 거죠. API Key나 O/Auth 이쩜영, M-TLS 같은 방식을 씁니다.
둘째, 권한 부여는 접근 권한 제어입니다. 최소 권한 원칙, Scope 설정, RBAC 같은 역할 기반 관리가 필요해요.
셋째, 전송 보안은 데이터 이동 간 도청과 변조를 방지합니다. TLS 1.2 이상의 HTTPS를 사용하고, 디지털 서명과 타임스탬프 검증을 해야죠.
넷째, 운영 관리 차원에서 Key Rotation, Secret 관리, 감사 로그를 지속적으로 관리해야 합니다.
보안 사고의 주요 원인은 취약한 인증 방식, 과도한 데이터 노출, 불충분한 로깅과 모니터링입니다. 

데이터 표준과 스키마에 대해 살펴봅시다.
왜 표준이 필요할까요? 서로 다른 벤더의 시스템이 소통하려면 공통 언어가 필요하기 때문입니다. 
ISA-9/5나 IEC 6/2/2/6/4 같은 국제 표준이 ERP와 MES 간 인터페이스를 정의하죠.
주요 핵심 가치는 시스템 간 상호운용성을 확보해서 통합 비용을 절감하고, 데이터 일관성을 유지하여 신뢰할 수 있는 의사결정을 지원하는 겁니다.
주요 데이터 교환 표준으로 B-Two-MML이 있습니다. ISA-9/5 기반의 XML 스키마 구현체로, ERP-MES 간 데이터 전송 포맷의 사실상 표준이에요. 
OPC UA는 플랫폼 독립적 통신 구조로, 단순 데이터를 넘어 정보 모델까지 제공합니다.
마스터 데이터 관리도 중요하죠. 품목, 공정, 설비, BOM/BOP의 식별자와 속성 정의가 일치해야 연동 오류를 막을 수 있습니다.
버전 및 변경 관리도 필수입니다. PLM에서 ECO가 발생하면 변경된 BOM과 도면이 ERP와 MES에 즉시 동기화돼야 구형 자재 사용을 방지할 수 있죠.
퍼듀 모델 계층 구조를 보면 L-four가 ERP, L-three가 MES, 
L-Two가 Scada로 실시간 연동이 이뤄집니다.

이제 두 번째 섹션으로 넘어가겠습니다. 실제 비즈니스 가치와 다양한 적용 사례를 중심으로 시스템 연동의 필요성을 구체적으로 살펴보겠습니다.

가장 빈번하고 필수적인 연동이 바로 MES와 ERP의 연동입니다. 생산 계획의 실행과 생산 결과의 회신을 자동화하는 거죠.
먼저 Downstream 흐름을 보면, ERP에서 MES로 생산계획과 작업지시가 내려갑니다. 자재 명세서, 소요량, 납기일, 우선순위 정보가 함께 전달되죠. 
Upstream 흐름은 MES에서 ERP로, 작업 완료 실적, 양품·불량 수량, 자재 빽플러시 자동 차감, 설비 가동 시간 등이 올라갑니다.
설계 시 몇 가지 고려해야될 사항들이 있습니다. 동기화 시점을 실시간으로 할지 배치로 할지 결정해야 하고, 
부분완료, 취소, 재작업 같은 예외 처리 로직이 필요해요. 
단위 변환도 중요합니다. 구매단위는 박스인데 불출단위는 개일 수 있거든요.
기대 효과는 명확합니다. 수기 입력이 완전히 제거되고, 입력 오류는 0%로, 지시 전달 시간은 90% 단축됩니다. 
실시간 원가와 재고 정확도 덕분에 월말 결산 기간이 3일에서 0.5일로 줄어들고, 재고 불일치 원인 추적이 가능해집니다.

두 번째 사례는 제품 개발과 양산의 간극을 줄이는 MES-PLM 연동입니다. 설계 변경 사항을 실시간으로 생산 현장에 배포하는 거죠.
PLM에서 MES로는 E-BOM에서 M-BOM로 자동 변환 및 매핑되고, 공정 정의, 표준 시간, 작업 표준서, 도면 파일 URL이 전달됩니다. 
반대로 MES에서 PLM으로는 공정별 불량률과 품질 측정 데이터, 설비 제약에 따른 설계 변경 요청, 초도품 검사 결과가 피드백됩니다.
연동 설계의 핵심 포인트는 변경점 관리입니다. Four-M 관점에서 설계 변경 시점과 재고 소진 정책을 정의해야 하죠.
버전 정합성도 중요합니다. 구버전 도면이 생산에 투입되면 안 되니까요. BOM 구조 차이, 즉 기능 중심 설계 구조와 공정 중심 생산 구조 간의 매핑도 필요합니다.
기대 효과로는 양산 준비 기간이 2주에서 2일로 단축되고, DFM 덕분에 설계 품질이 향상되며, 양산 이관 후 설계 변경 건수가 40% 감소합니다. ECO/ECR 승인 프로세스가 표준화돼서 미승인 변경 사항이 생산에 투입되는 것도 막을 수 있죠.

마지막 사례는 ERP-PLM 연동, 즉 기술 정보와 경영 자원을 일원화하는 연동입니다. 개발과 양산 간 단절을 제거하죠.
PLM에서 ERP로는 신규 품목 코드 채번과 생성, E-BOM 정보, 기술 문서 링크와 리비전 정보가 전달됩니다. 기대효과는 중복 마스터가 제거되서 품목 이중 등록이 방지되고, 기준 정보가 일치되죠.
ERP에서 PLM으로는 자재 표준 단가와 실제 원가, 공급업체 정보와 단종 여부, 가용 재고 현황이 조회됩니다. 
설계 시 재사용을 유도할 수 있죠. 이를 통해 구매 리드타임이 단축되며, 목표 원가 달성과 자재 발주 즉시화가 가능해집니다.
설계 시 고려사항에는 속성 매핑이 있습니다. 길이나 무게 단위가 다를 수 있기 때문에 차이를 보정해야돼요. 
변경 관리도 중요한데, ECO 승인 후 ERP에 반영하는 시점을 정의해야 합니다. 대체품 로직도 복잡하죠. 설계 대체품과 구매 대체품이 다를 수 있거든요. 
따라서 설계 변경이 자재 마스터에 미치는 영향을 분석해서 프로세스 통합을 이뤄야합니다.

이러한 시스템간의 연동 필요성을 KPI와 ROI 관점에서 가치를 따져봐야됩니다.
먼저 정량적 기대 효과를 예시 데이터로 살펴보겠습니다.
입력 오류율이 3.2%에서 0.6%로, 81% 감소했습니다. 지시 처리 시간은 45분에서 8분으로, 82% 단축됐어요.
ROI 산정 요소는 세 가지입니다. 단순 반복 입력 업무 제거로 연간 Man-Hour가 절감되고, 잘못된 발주와 생산으로 인한 폐기 비용이 감소하며, 재고 보유 기간 단축으로 금융 비용까지 절감됩니다.
주요 KPI 지표 변화를 보면, 데이터 동기화 주기가 데일리에서 Real-time으로 바뀌었고, 마스터 데이터 일치율이 92%에서 99.8%로 올랐습니다. 
문제 원인 파악 시간은 4시간에서 10분으로 대폭 줄었죠.

다음은 성공적인 연동을 위한 다섯 단계 로드맵입니다. 
1단계 현황 진단에서는 애즈 이즈 시스템을 분석하고, 데이터 요구사항을 도출하며, 연동 범위를 확정합니다.
2단계 데이터 표준화에서는 매핑 테이블을 정의하고, 보안 정책을 수립하며, 인터페이스 명세서를 작성합니다.
3단계 PoC 수행에서는 핵심 기능 파일럿을 구현하고, 기술적 난제를 해결하며, 성능을 검증하죠.
4단계 단계적 확산에서는 본 구축과 배포를 진행하고, 레거시 시스템을 연동하며, 전체 프로세스에 적용합니다.
5단계 운영과 모니터링에서는 안정화와 유지보수를 하고, 사용자 교육을 실시하며, 모니터링 대시보드를 운영합니다.
각 게이트마다 명확한 의사결정 기준을 설정하고, PoC 단계에서 발견된 기술적 리스크를 완전히 해소한 후 확산 단계로 진입해야 시행착오를 최소화할 수 있습니다.

시스템 연동시 발생 가능한 핵심 리스크와 대응 전략을 살펴보겠습니다.
첫째, 레거시 스키마 불일치 문제입니다. 서로 다른 시스템 간 데이터 필드와 형식이 호환되지 않을 수 있어요. 따라서, 표준 매핑 테이블을 정의하고, 데이터 변환 로직을 미들웨어에 위임해야 합니다.
둘째, 성능 병목 현상입니다. 대량 데이터 처리 시 응답 지연과 타임아웃이 발생하죠. 실시간 처리가 불필요하면 비동기나 배치로 전환하고, 자주 조회되는 마스터 데이터는 캐싱을 적용해야 해요.
셋째, 장애 전파입니다. 한 시스템의 장애가 연동된 전체 시스템으로 확산될 수 있어요. 서킷 브레이커 패턴을 도입하고, 실패 메시지는 데드 레터 큐에 격리해서 재처리해야 합니다.
넷째, 거버넌스 부재입니다. 무분별한 API 생성과 버전 관리 실패가 발생하죠. API 카탈로그를 구축해서 중앙화된 관리를 하고, 명확한 버전 정책과 Deprecation 예고제를 운영해야 합니다.

이제 실습 파트로 들어갑니다. Python을 활용해서 공개 Rest API를 호출하고, 모의 MES API 연동과 인증, 오류 처리 기법을 직접 실습해보겠습니다.

실습 환경을 점검해볼까요? Python 3.10 이상이 필요하고, Path 환경변수가 등록돼 있어야 합니다. 터미널에서 python version 명령으로 확인하세요.
필수 라이브러리는 두 가지입니다. HTTP 클라이언트용 requests와 모의 MES 서버용 플라스크를 pip install로 설치하세요. 
코드 에디터는 Visual Studio Code를 권장하고, Python Extension을 활성화하면 좋습니다.
네트워크 접속도 확인해야 합니다. 외부 인터넷 접속이 가능한지, 사내망이라면 Proxy 설정이나 예외 처리가 필요한지 점검하세요.

첫 번째 실습입니다. Python의 requests 라이브러리로 공개 테스트 API인, json-Place-holder를 호출해볼게요.
코드를 보시면, 먼저 requests를 import하고, 대상 URL을 설정합니다. Get 요청을 보낼 때 time-out을 5초로 설정하는 게 좋아요. 
응답 상태코드를 확인해서 200 OK가 나오면 json 데이터를 파싱합니다.
터미널 결과를 보면 Status Code가 200이 나오고, Response Data에 user-Id, id, 타이틀, 컴플리티드 같은 필드가 들어있죠. 
응답받은 데이터에서 title 값을 출력할 수 있습니다. 이렇게 기본적인 API 호출 구조를 익힐 수 있어요.

두 번째 실습은 Flask로 가상 MES 서버를 만들고 호출하는 겁니다. 포트 5001번에 로컬 서버를 띄우고, /mes/order 엔드포인트를 만들어요.
서버 코드를 보면, Flask를 import하고, @app.Get 데코레이터로 라우팅을 정의합니다. Get_work_order 함수에서 가상의 작업지시 데이터를 만들어서 json으로 리턴하죠. order-Id, item-Code, status, QTY 같은 필드가 들어있습니다.
클라이언트 호출 코드는 간단합니다. 클라이언트 URL로 Get 요청을 보내고, 응답을 json으로 파싱해서 출력하면 됩니다.
터미널을 Split View로 나눠서 한쪽에서는 서버를 실행하고, 다른 쪽에서는 클라이언트를 실행하면 MES Response가 제대로 나오는 걸 확인할 수 있어요.

세 번째 실습은 실전 수준의 코드입니다. API Key 인증과 리트라이 전략을 구현해볼게요.
먼저 Session을 생성하고, 공통 헤더에 'X-API-Key'를 추가합니다. 이렇게 하면 모든 요청에 인증키가 자동으로 붙어요.
리트라이 전략은 url-lib-three의 리트라이 클래스를 사용합니다. total을 3으로 설정하면 최대 3회 재시도하고, backoff_factor를 0.3으로 하면 0.3초, 0.6초, 1.2초 식으로 대기 시간이 증가합니다. 
스테이터스_force-list에는 500번대 서버 에러를 넣어요.
HTTP-Adapter에 리트라이 전략을 장착하고, Session에 mount하면 됩니다. API 호출 시 time-out을 3초로 설정하고, raise_for_status를 호출하면 200 OK가 아닐 때 예외가 발생하죠.
마지막으로 try-except 문으로 Request-Exception을 잡아서 에러 처리를 하면 완성입니다. 서버가 꺼져있으면, "Max retries exceeded" 메시지가 나오는 걸 확인할 수 있어요.

이제 네 번째 섹션으로 넘어갑니다. 반복 작업을 처리하는 RPA와 스스로 판단하고 생성하는 에이아이 에이전트의 결합 아키텍처를 탐구해보겠습니다.

먼저 RPA 개요와 적용 영역을 살펴보죠. RPA, Robotic Process Automation은 사람이 컴퓨터로 하는 규칙 기반 반복 업무를 소프트웨어 로봇이 대신 수행하는 기술입니다.
핵심 특징은 세 가지예요. GUI나 웹 화면을 인식해서 자동 제어하고, 기존 IT 시스템 변경 없이 비침해적으로 연동하며, 24시간 365일 중단 없이 업무를 수행합니다.
주요 적용 영역으로는 데이터 이관 및 검증이 있습니다. 서로 다른 시스템 간 복사·붙여넣기와 포맷 변환을 자동화하죠. 
정기 리포트 작성도 있어요. ERP와 MES 데이터를 취합해서 엑셀이나 PDF로 일일 보고서를 만듭니다. 
마스터 데이터 등록, 즉 신규 품목이나 거래처 정보를 다수 시스템에 일괄 등록하는 것도 가능합니다.
하지만 기존 RPA의 한계가 있습니다. 비정형 데이터, 즉 이미지나 자필 문서 같은 구조화되지 않은 데이터는 처리하기 어려워요. 예외 처리도 취약해서 규칙에서 벗어나면 멈추거나 오류가 나죠. UI나 화면 구성이 바뀌면 스크립트를 재개발해야 하는 변화 민감성도 문제입니다.

다음으로 살펴볼 에이아이 에이전트는 단순한 언어 생성을 넘어서는 자율 시스템입니다. 엘엘엠, Planning, Tools, Memory가 결합된 구조죠.
에이아이 에이전트의 네 가지 구성 요소를 볼까요?
Brain은 GPT-four나 Claude 같은 LLM으로 추론과 계획 수립, 의사결정의 핵심입니다. Planning은 복잡한 목표를 단계별 하위 작업으로 분해하고 실행 순서를 결정하죠.
Tools는 API 호출, 코드 실행, 웹 검색 같은 외부 세계와의 상호작용 수단입니다. Memory는 대화 컨텍스트를 저장하고, 이전 액션의 결과를 피드백으로 활용하며, 반복 학습을 통해 최적화합니다.
주어진 목표를 달성하기 위해 스스로 계획을 수립하고, 적절한 도구를 사용해서 행동하며, 결과를 관측해서 반복 수행하는 자율 시스템이에요.

RPA와 에이아이 에이전트의 결합된 아키텍처를 살펴보겠습니다. RPA와 에이아이 에이전트를 결합하면 지능형 자동화가 가능합니다. 에이아이 에이전트가 판단을 하고, RPA가 실행을 담당하는 구조죠.
아키텍처를 보면, 사람이 자연어로 업무를 요청하면 에이아이 에이전트의 LLM이 의도를 파악하고 실행 계획을 수립합니다. 필요하면 외부 API나 데이터베이스에서 정보를 조회하고, 문서에서 필요한 정보를 추출하죠.
그 다음 RPA Bot에게 명령을 전달합니다. RPA Bot은 ERP 화면에 로그인해서 데이터를 입력하고, MES 시스템을 조작하며, 결과를 캡처해서 다시 에이아이 에이전트에게 피드백합니다. 
에이아이 에이전트는 결과를 검증하고, 필요하면 재시도하거나 예외 처리를 하죠. 최종적으로 사람에게 결과를 리포팅하고, 전 과정을 로깅해서 감사 추적이 가능하도록 합니다.

RPA와 에이아이 에이전트가 결합된 적용 시나리오를 세 가지 보겠습니다. 
첫 번째는, 구매요청서로부터 발주 생성입니다. 이메일에서 구매 요청을 읽고, 에이아이 에이전트가 품목 코드와 수량, 납기를 추출하면 RPA가 ERP에 자동 등록하죠.
두 번째 시나리오는, 품질성적서로부터 불량 등록입니다. 불량 사진이나 작업자 메모를 통해 현장 기록을 입력받아서 에이전트가 불량 유형을 분류하고 원인을 요약합니다. 그 후 API 호출을 통해 MES로 불량을 등록하는거죠.
마지막은 설계 변경 공지에서 ECO, 즉 Engineering Change Order 입니다. PLM 시스템에 Cad 도면에 변경이 발생하면 에이전트가 변경 사유서 초안을 작성하죠. 
최종적으로 RPA가 엔지니어링 변경 지시서를 등록하고 유관 부서에 자동으로 메일을 발송합니다.

RPA 단독 모델과 에이전트가 결합된 RPA를 비교해보겠습니다.
먼저, 규칙 기반 RPA 단독 모델은 고정된 시나리오만 처리할 수 있습니다. 판단이 조건문에 따라 분기되고, 예외가 발생하면 사람이 개입해서 수동으로 처리해야 하죠.
반면에, 에이아이 에이전트가 결합된 RPA 모델은 동적 판단이 가능합니다. 
엘엘엠이 비정형 데이터를 이해하고, 컨텍스트를 추론해서 최적 액션을 선택하며, 스스로 예외를 처리하고 재시도합니다. 사람은 최종 승인만 하면 되는 구조죠.

규친 기반 RPA에 에이아이 에이전트를 결합하면 다음과 같은 정량적 성과가 나타납니다. 업무 성공률이 92%에서 98%로 향상되고, 건당 처리 시간이 4.2분에서 1.2분으로 62% 단축돼요. 
KPI 개선도를 보면, 자동화 커버리지는 40%에서 85%로 증가되고, 재처리율은 8.5%에서 1.2%로 껀당 처리 비용은 2.5 달러에서 0.4$로 감소되었습니다.

자, 이제 마지막 섹션입니다. RPA와 에이아이 에이전트를 결합한 미니 POC를 실습해보겠습니다.
CSV 주문 데이터를 기반으로 파라미터를 자동으로 생성하고, 모의 ERP API를 호출해서 로깅 및 리트라이하는 과정을 실습해보죠.

실습 준비 사항입니다. 먼저 개발 환경은 실습 1과 같이 준비해주세요.
다음으로 자동화 대상이 되는 소스 데이터 파일을 CSV로 준비하고, 목표 시나리오로 동작 로직을 정의합니다. 마지막으로 API 통신 상태를 확인하고 디버깅을 해야하죠.

첫번째 실습은 pandas를 사용해서 CSV 파일을 읽고, 각 행을 순회하면서 ERP API로 전송하는 파이프라인을 구현합니다.
코드를 보면, 먼저 pd.read_csv로 파일을 읽어옵니다. 다음으로 ERP 주문 생성 API 엔드포인트를  로컬 host에 erp-오더로 입력하죠.
이제, iter-rows로 데이터 프레임 행을 순회합니다. 각 행의 데이터를 딕셔너리로 만들어서 requests.post로 전송하고, 응답 코드가 200이면 성공, 아니면 에러 로그를 남기죠.

자, 이제 실습 2의 마지막 단계입니다. 이번 실습에서는 운영 환경에서 반드시 필요한 방어 로직을 구현해보겠습니다
화면의 코드를 보시면, 3가지 핵심 기능이 구현되어 있습니다.
첫 번째, 로깅 설정입니다. 일번 라인에서 logging 모듈을 import하고, 사번 라인에서 로그 포맷을 설정합니다. 시간, 로그 레벨, 메시지가 자동으로 기록되기 때문에 나중에 문제가 발생했을 때 추적이 가능합니다.
두 번째, 재시도 로직입니다. 육번 라인의 call_api_with_retry 함수는 최대 3회까지 재시도합니다. 팔번 라인의 뽈문을 보시면 매 시도마다 로그를 남기죠. 십이번 라인에는 3초 타임아웃이 설정되어있습니다.
세 번째, 예외 처리입니다. 십구번 라인의 Exception 블록에서 모든 예외를 포착하고, 이십삼번 라인에서 1초 대기 후 재시도합니다. 이걸 Backoff Strategy라고 부릅니다.
하단의 터미널 출력을 보시죠. 첫 번째 시도에서 타임아웃 에러가 발생했습니다. 주황색으로 표시된 Warning 로그를 보시면 "Connection failed: Read timed out"이라고 나오죠.
하지만 시스템이 자동으로 두 번째 시도를 하고, 이번엔 성공했습니다. 초록색 "Success" 메시지와 함께 주문 번호 PO-9/9/8/1이 생성되었습니다.
이 로직이 왜 중요할까요? 실제 제조 현장에서 ERP 서버나 MES 서버가 순간적으로 부하가 걸릴 수 있습니다. 만약 재시도로직이 없다면, 한 번의 네트워크 지연 때문에 전체 주문 처리가 실패하게 됩니다.
하지만 이렇게 로깅과 재시도를 구현하면, 99% 이상의 성공률을 달성할 수 있고, 실패한 케이스도 로그를 통해 정확히 추적할 수 있습니다.

마지막으로 운영 체크리스트를 보시죠. 안정적이고 지속 가능한 시스템 연동 운영을 위해 준수해야 할 네 가지 핵심 관리 영역과 실천 항목입니다.
첫번째는 버전 관리입니다. API 변경에 따른 호환성 유지와 명세 관리가 필수죠. API 스키마 버전 명시와 문서화를 체크하고, 개발자를 위한 예제 코드 및 샌드박스 제공 여부를 확인합니다.
두 번째는 관측성입니다. 시스템의 상태를 실시간으로 모니터링하고 추적 가시성을 확보해야 하죠. 전구간 추적을 위한 Request ID를 발급하고, 중앙화된 추적 로그 수집과 실시간 대시보드를 구축해야합니다.
세 번째는 안전성입니다. 장애 발생 시 피해를 최소화하고 자동 복구 전략을 수립해야하죠. 장애 전파 차단을 위한 서킷 브레이커를 도입하고, 데드 레터 큐로 실패 메시지를 재처리하세요.
마지막 거버넌스는 비즈니스 프로세스와 연계된 변경을 통제합니다. ECO나 ECR 같은 변경 관리 프로세스와 배포 연동을 확인하고, 정기적인 릴리스 캘린더 운영 및 사전 공지 체계를 구축하죠.

오늘 강의를 정리하겠습니다. API는 제조 IT 시스템 간 데이터 연동의 핵심이고, MES, ERP, PLM 연동을 통해 휴먼 에러 제거와 리드타임 단축이 가능합니다. Python으로 실제 API를 호출하고, 인증과 에러 처리를 구현하는 역량을 익혔죠.
RPA와 에이아이 에이전트를 결합하면 비정형 데이터 처리와 지능형 예외 처리가 가능해집니다. 규칙 기반을 넘어선 자율 시스템 설계가 미래의 제조 IT 방향이죠.
이상 강의를 마치도록 하겠습니다. 감사합니다!
