[슬라이드 1] 표지
안녕하십니까, 여러분. 오늘 국립창원대학교 PRU 재직자 교육 시간에 함께 하게 되어 반갑습니다. 지금부터 '커뮤니케이션 자동 Agent 및 자동 응답 정책'이라는 주제로 25분간 여러분과 함께 하겠습니다.

본 교육은 실무 운영 담당자분들과 기획, IT, 보안 책임자분들을 위해 특별히 설계되었어요. 이론 12분, 실습 10분으로 구성하여 실제 업무에 바로 적용하실 수 있도록 준비했습니다.

오늘 교육을 통해 세 가지 핵심 학습 성과를 달성하실 수 있는데요. 먼저 자동 응답 에이전트의 설계 원리를 정확히 이해하시게 될 겁니다. 그리고 Python으로 작성된 이메일과 메신저 PoC 코드를 직접 구동해보는 실습을 진행하죠. 마지막으로 우리 조직에 딱 맞는 자동 응답 정책 초안을 직접 도출해보실 거예요.

[슬라이드 2] 목차
자, 그럼 오늘의 학습 로드맵을 함께 살펴볼까요? 총 6개의 섹션으로 구성되어 있습니다.

첫 번째 섹션에서는 자동화 개요와 필요성을 다룰 예정이에요. 왜 지금 우리 조직에 커뮤니케이션 자동화가 필요한지, 정량적이고 정성적인 기대효과는 무엇인지 분석해보겠습니다.

두 번째는 커뮤니케이션 Agent의 기초입니다. Agent가 어떻게 작동하는지 구조를 뜯어보고요, 규칙 기반 방식과 LLM 방식을 비교 분석하겠습니다.

세 번째와 네 번째 섹션이 바로 Python 실습 파트인데요. 먼저 이메일 자동 응답 시스템을 구축해봅니다. IMAP과 SMTP 라이브러리를 활용해서 메일을 분류하고 자동으로 회신하는 코드를 직접 작성하죠. 그다음 메신저 자동 응답 시스템으로 넘어가는데, Slack API와 이벤트 봇을 활용한 실시간 응답 처리를 구축해볼 겁니다.

다섯 번째는 자동 응답 정책 수립이에요. 보안, 개인정보 보호, 톤앤매너 가이드라인 등 실전 운영에 필요한 정책들을 정리합니다. 여섯 번째 섹션에서는 실제 성공 사례를 분석하고 운영 시나리오를 시뮬레이션해보죠. 마지막으로 정리와 Q&A 시간을 갖도록 하겠습니다.

[슬라이드 3] Section 01 학습 목표
자, 이제 본격적으로 첫 번째 섹션인 '자동화 개요 및 필요성'으로 들어가볼까요? 이 섹션의 학습 목표는 세 가지입니다.

첫째, 조직 커뮤니케이션 자동화의 배경을 제대로 이해하는 거예요. 단순 반복 업무에서 벗어나 진짜 가치 있는 커뮤니케이션에 집중하기 위한 첫걸음이죠. 왜 지금 우리 조직에 자동 응답 Agent가 필요한지, 그 핵심 가치를 정의해볼 겁니다.

둘째, 정량적이고 정성적인 효과 포인트를 파악하는 거예요. 막연히 '좋을 것 같다'가 아니라 구체적인 수치와 지표로 효과를 측정할 수 있어야 합니다.

셋째, 필수 리스크 항목을 미리 인지하는 겁니다. 자동화를 도입하면서 발생할 수 있는 문제점들을 사전에 파악하고 대비책을 세워야 하거든요.

[슬라이드 4] 현황 분석
그럼 현재 우리가 직면한 업무 커뮤니케이션의 페인포인트부터 진단해보죠. 자동화 시스템 도입 전, 조직이 마주하고 있는 비효율적인 현황과 구조적 문제점들입니다.

첫 번째 문제는 반복 질의 및 응답 지연이에요. 동일한 질문에 대해 계속 같은 답변을 반복하다 보니 업무 피로도가 급증하죠. 특히 야간이나 주말에는 응답 공백이 발생해서 SLA, 즉 서비스 수준 협약을 지키기가 정말 어렵습니다.

두 번째는 응답 품질과 톤앤매너의 불일치예요. 담당자마다 답변 스타일이 제각각이다 보니 조직의 브랜드 일관성이 무너지는 거죠. 더 심각한 건 중요한 이슈가 적시에 상급자에게 에스컬레이션되지 않고 그냥 묻혀버릴 위험이 있다는 겁니다.

세 번째 문제는 채널의 파편화입니다. 이메일, 사내 메신저, 그룹웨어 포털 등 소통 채널이 너무 분산되어 있어요. 이력 추적이 불가능하고 통합적인 데이터 관리가 안 되는 상황이죠.

네 번째는 인력 의존형 운영의 한계예요. 입시나 수강신청 같은 시기에 문의량이 폭증하면 유연한 대응이 불가능합니다. 운영 인력을 증원하지 않고서는 서비스 확장성을 확보할 수 없는 구조적 문제가 있는 거죠.

[슬라이드 5] 효과 및 목표
그렇다면 자동화 시스템을 도입하면 어떤 효과를 기대할 수 있을까요? 구체적인 KPI와 함께 살펴보겠습니다.

먼저 정성적인 효과부터 볼게요. 대기 시간 없는 즉시 응답으로 사용자 경험이 획기적으로 개선됩니다. 24시간 7일 상시 가용성이 확보되어 야간이나 주말, 공휴일 업무 공백이 완전히 해소되죠.

대규모 처리량, 즉 Throughput 확대도 가능해요. 수강신청 같은 피크 타임의 트래픽에도 유연하게 대응할 수 있습니다. 표준화된 응답 품질 유지로 톤앤매너의 일관성이 확보되고요, 모든 이력이 투명하게 관리되어 감사 추적이 가능해집니다.

이제 정량적 KPI를 보시죠. 평균 응답시간, 즉 ART 단축이 핵심 목표입니다. 초동 응답 시간인 FRT는 3분 이내로 설정했어요. 자동 해결률은 40% 이상을 목표로 하고요, 고객 만족도 CSAT는 5점 만점에 4.5점을 달성하려고 합니다. 복잡한 문의를 담당자에게 넘길 때 핸드오버 정확도는 95%를 유지하는 게 목표예요.

[슬라이드 6] 운영 정책 가이드
신뢰할 수 있는 자동 응답 시스템을 운영하려면 윤리, 보안, 거버넌스를 철저히 점검해야 합니다. 4대 필수 점검 항목을 살펴볼게요.

첫째, 개인정보 보호입니다. 수집 최소화 원칙에 따라 업무 처리에 불필요한 개인정보 수집을 원천 차단해야 해요. 주민번호나 전화번호 같은 민감정보는 로그 저장 시 자동으로 마스킹 처리하는 거죠.

둘째, 투명성과 신뢰예요. 답변 출처를 명확히 밝혀서 자동 생성된 답변임을 고지해야 합니다. 예를 들어 'AI Bot'이라고 표시하는 거죠. 사용자가 요청하면 실제 담당자와 연결되는 휴먼 핸드오버 경로를 필수로 제공해야 합니다.

셋째, 안전성과 제어 규칙이에요. 욕설이나 비하 발언 같은 부적절한 입력에 대한 금칙어 블랙리스트를 운영해야 하죠. 신뢰할 수 있는 도메인과 사용자 그룹에 한해서만 서비스를 제공하는 화이트리스트 운영도 중요합니다.

넷째, 책임성과 감사입니다. 모든 대화와 처리 내역을 기록해서 사고 발생 시 추적 가능성을 확보해야 해요. 오동작이 발생하면 해당 상황을 재현하고 원인을 분석할 수 있는 체계를 마련하는 거죠.

이 체크리스트는 시스템 설계 단계에서 반드시 검토되어야 하고요, 운영 중에도 정기적인 점검이 필요합니다.

[슬라이드 7] Section 02 학습 목표
이제 두 번째 섹션인 '커뮤니케이션 Agent 기초'로 넘어가볼까요? 이 섹션에서는 Agent의 작동 원리를 깊이 있게 이해하는 시간을 갖겠습니다.

성공적인 자동화를 위해서는 도구의 작동 원리와 특성을 정확히 알아야 해요. 단순한 챗봇을 넘어선 지능형 Agent의 구조를 학습하는 거죠.

첫 번째 학습 목표는 Agent 개념과 구성요소를 이해하는 겁니다. Agent가 무엇이고 어떤 부품들로 이루어져 있는지 명확히 파악해야 합니다.

두 번째는 규칙 기반 방식과 LLM 방식을 비교하고 하이브리드 전략을 수립하는 거예요. 각각의 장단점을 이해하고 우리 조직에 최적화된 방식을 선택해야 하죠.

세 번째는 품질지표 정의와 테스트 방법론입니다. 어떻게 성능을 측정하고 개선할 것인지 구체적인 방법론을 배우게 될 겁니다.

[슬라이드 8] Agent 정의와 구성요소
그럼 Agent가 정확히 무엇인지부터 정의해볼게요. Agent는 사용자의 의도를 파악하고 지식 기반으로 자동 응답과 행동을 수행하는 지능형 엔진입니다.

좀 더 풀어서 설명하면, 인텐트, 즉 의도를 파악하고요, 필요한 지식에 접근하여 적절한 응답을 생성하고 행동 수행을 자동화하는 거예요. 이 세 가지가 Agent의 핵심 기능입니다.

이런 Agent는 5대 구성요소로 이루어져 있어요. 첫째는 인텐트 분류기입니다. 사용자 메시지의 의도가 문의인지 요청인지 신고인지를 파악하는 모델이에요.

둘째는 지식 베이스예요. FAQ, 매뉴얼, 문서 등 답변 생성을 위한 데이터 저장소죠. 셋째, 정책과 룰 엔진입니다. 보안 규칙, 응답 권한, 워크플로우 제어 로직을 담당해요.

넷째는 응답 템플릿이에요. 표준화된 답변 양식과 동적 데이터 삽입 구조를 제공합니다. 마지막 다섯째는 채널 커넥터와 로깅이죠. 이메일이나 메신저 API를 연동하고 모든 대화를 기록하는 모니터링 시스템입니다.

이 다섯 가지 요소가 유기적으로 결합되어 사용자 맥락을 이해하고, 지식 기반으로 추론하며, 자율적으로 행동을 수행하는 거예요.

[슬라이드 9] 접근 방식 비교
커뮤니케이션 에이전트를 설계할 때 두 가지 핵심 접근 방식이 있습니다. 규칙 기반과 LLM 기반이죠. 각각의 장단점을 비교해보겠습니다.

먼저 규칙 기반 방식의 장점은 예측 가능성과 안전성이에요. 사전에 정의된 트리 구조대로만 동작하기 때문에 답변의 일관성이 완벽하게 보장됩니다. 내부 규정 준수, 즉 컴플라이언스에 유리하죠.

하지만 확장 비용이 기하급수적으로 증가한다는 단점이 있어요. 모든 대화 시나리오를 인간이 미리 예측해서 룰을 만들어야 하거든요. 커버리지를 넓힐수록 관리 비용이 폭증하는 구조예요.

반면 LLM 기반의 장점은 유연한 맥락 이해 능력입니다. 자연어 이해 능력이 뛰어나서 사용자의 복잡한 의도를 파악하고요, 학습되지 않은 미지의 질문에도 대응할 수 있어요.

단점은 비용과 통제 필요성이에요. API 토큰 비용이 발생하고요, 환각 현상, 즉 할루시네이션을 방지하기 위한 가드레일 설계가 필수적입니다.

그래서 우리가 권장하는 전략은 하이브리드 방식이에요. 'Rule First, LLM Assist' 접근법이죠. 정형화된 단순 문의는 규칙 기반으로 즉시 처리해서 비용을 절감하고요, 해결되지 않는 복잡한 질의만 LLM에게 전달하는 겁니다. 이렇게 하면 정확도와 효율성을 동시에 확보할 수 있어요.

[슬라이드 10] 표준 워크플로우 8단계
자, 이제 Agent가 실제로 어떻게 작동하는지 표준 워크플로우를 살펴보죠. 크게 실시간 처리 파이프라인과 비동기 피드백 루프로 나뉩니다.

실시간 처리 파이프라인부터 볼게요. 1단계, 수신 이벤트예요. 이메일이나 메신저로 메시지가 들어옵니다. 2단계는 전처리와 익명화죠. 노이즈를 제거하고 개인정보를 마스킹 처리해요.

3단계는 인텐트 분류입니다. 규칙 기반이나 LLM을 사용해서 사용자의 의도를 파악하는 거죠. 4단계에서는 지식과 템플릿을 조회해요. FAQ나 데이터베이스를 검색합니다.

5단계는 응답 생성과 검증이에요. 템플릿에 데이터를 매핑하거나 LLM으로 응답을 생성하죠. 6단계에서 API를 호출해서 실제로 응답을 발송합니다.

여기까지가 실시간 처리고요, 이제 비동기 피드백 루프로 넘어갑니다. 7단계는 로깅과 피드백이에요. 처리 결과를 데이터베이스에 저장하고 사용자 만족도인 CSAT를 수집하죠.

마지막 8단계는 모델과 룰 개선입니다. 오분류된 데이터로 학습하고 신규 인텐트와 정책을 반영해요. 개선 사항이 다시 3단계와 4단계로 업데이트되면서 지속적인 품질 향상이 이루어지는 구조예요.

[슬라이드 11] 품질지표와 테스트 전략
성공적인 Agent 운영을 위해서는 반드시 측정해야 할 핵심 지표와 안정성 검증 방법론이 필요합니다.

먼저 핵심 평가 지표부터 볼게요. 첫째는 정확성과 적합성이에요. 사용자의 인텐트 분류 정확도인 Accuracy를 측정하고요, 답변의 문맥 적합성도 평가해야 합니다. Agent가 정의된 톤앤매너를 일관되게 유지하는지도 중요한 지표죠.

둘째는 운영 효율성 지표입니다. 평균 응답 시간인 FRT를 모니터링하고요, 자동 해결률인 Deflection Rate도 추적해야 해요. 인간 상담원에게 이관할 때 핸드오버 정확도도 측정해야 하죠.

테스트 방법론도 살펴볼까요? 먼저 오프라인 정답셋과 샌드박스 테스트예요. 사전에 정의된 Golden Dataset으로 회귀 테스트를 수행해서 기본 성능을 보장합니다. 격리된 샌드박스 환경에서 실제 데이터 흐름을 시뮬레이션하는 AB 테스트도 중요해요.

다음은 레드팀과 스트레스 테스트죠. 금칙어 우회 시도나 유도 질문 같은 적대적 공격, 즉 Red Teaming에 대한 방어력을 검증해야 합니다. 대량 트래픽이 발생했을 때 시스템의 응답 안정성도 점검해야 하고요.

[슬라이드 12] Section 03 학습 목표 (계속)
첫 번째 학습 목표는 이메일 파이프라인 아키텍처를 이해하는 겁니다. 메일이 어떻게 수신되고, 분류되고, 응답이 발송되는지 전체 흐름을 파악하는 거죠.

두 번째는 Python으로 수신, 분류, 응답 PoC를 직접 구현하는 거예요. 실제로 손으로 코드를 작성하면서 원리를 체득하게 될 겁니다.

세 번째는 운영 안전장치 설계입니다. 중복 발송이나 무한 루프 같은 사고를 예방하는 안전 메커니즘을 구축해야 하거든요.

[슬라이드 13] 이메일 아키텍처와 운영 포인트
이메일 자동응답 시스템의 구성요소와 운영 핵심 포인트를 살펴보겠습니다.

시스템은 크게 세 가지 코어 컴포넌트로 구성돼요. 첫째는 수신 파트입니다. IMAP이나 POP3 프로토콜을 통해 메일함을 감시하고 메일을 가져오는 Fetch 작업이죠.

둘째는 처리 및 분류 파트예요. 인텐트 분류기가 정규식이나 LLM을 활용해서 의도를 파악하고요, 템플릿을 매칭하며 컨텍스트를 분석합니다.

셋째는 발송 파트죠. SMTP 서버와 연동해서 HTML 템플릿을 렌더링하고 답장을 전송하는 겁니다.

운영 핵심 포인트도 네 가지 짚고 넘어가야 해요. 첫째, 보안 및 인증이에요. SPF, DKIM, DMARC 같은 도메인 인증 정책을 철저히 준수해야 발송 메일이 스팸으로 분류되지 않습니다.

둘째는 장애 대응력이죠. 일시적 네트워크 오류 시에는 지수 백오프 방식으로 재시도를 수행하고요, 실패한 메시지는 데드레터 큐에 보관해야 해요.

셋째는 안전장치입니다. Message-ID 기반 처리 이력 DB를 구축해서 중복 발송 방지와 무한 루프 응답 사고를 예방하는 거죠.

넷째는 제어 및 스케줄링이에요. 작업 큐, 크론 스케줄러, 상태 모니터링 체계를 갖춰야 합니다.

[슬라이드 14] 데이터 모델과 정책 훅
안정적인 자동 응답 시스템을 구동하기 위한 핵심 데이터 엔티티와 운영 개입 포인트를 정의해야 합니다.

먼저 핵심 엔티티를 볼게요. 인텐트와 템플릿이 가장 중요해요. 사용자 의도를 식별하는 intent와 이에 매핑되는 응답 양식인 template_id가 핵심이죠. 버전 관리와 다국어 변형을 포함하는 구조로 설계되어야 합니다.

보안 및 필터링 규칙도 엔티티로 관리해야 해요. White/Blacklist 도메인 관리, 금칙어 규칙, 데이터의 민감도 레벨을 체계적으로 정의하는 거죠.

정책 훅도 중요합니다. 첫째는 휴먼 인 더 루프예요. 자동 발송 전에 인간의 검토가 개입되는 기준점을 명확히 해야 하죠. 민감도가 'High'이거나 금칙어가 탐지된 경우에는 담당자 승인 큐로 라우팅하는 로직이 작동합니다.

둘째는 SLA 준수와 감사 로깅이에요. 응답 제한 시간인 Timebox를 초과하면 알림을 트리거하고요, 모든 처리 과정은 추후 감사를 위해 정의된 Audit Log Schema에 따라 기록되어야 합니다.

[슬라이드 15] CODE LAB 01 - 환경 설정
자, 이제 본격적으로 실습에 들어가봅시다. Python 개발 환경을 구성하고 보안을 위한 환경변수를 설정하는 방법을 안내해드릴게요.

사전 준비사항부터 체크해볼까요? Python 3.10 이상이 설치되어 있어야 하고요, pip 패키지 매니저는 최신 버전으로 업데이트해두세요. 테스트용 이메일 계정도 준비하셔야 하는데, Gmail 같은 서비스에서 IMAP과 SMTP를 활성화하고 앱 비밀번호를 발급받으셔야 합니다.

첫 번째 단계는 라이브러리 설치예요. 터미널에서 'pip install schedule' 명령어를 실행하시면 됩니다. imaplib, smtplib, email 모듈은 Python 표준 라이브러리에 포함되어 있어서 별도 설치가 필요 없어요.

두 번째 단계는 환경변수 설정입니다. .env 파일을 생성하셔야 하는데요, IMAP 수신용 설정으로 IMAP_HOST는 imap.gmail.com, IMAP_USER는 여러분의 이메일 주소, IMAP_PASS는 2단계 인증 앱 비밀번호를 입력하세요.

SMTP 발송용 설정도 필요합니다. SMTP_HOST는 smtp.gmail.com, SMTP_PORT는 587, SMTP_USER와 SMTP_PASS도 마찬가지로 입력하시면 돼요.

보안 주의사항 세 가지 꼭 기억하세요. 첫째, 실습 중에는 개인정보가 포함된 실제 고객 데이터를 절대 사용하지 마세요. 둘째, 비밀번호는 코드에 하드코딩하지 말고 반드시 .env 파일로 분리하세요. 셋째, 프로젝트 루트에 .gitignore를 생성해서 민감한 설정 파일이 공유되지 않도록 하세요.

[슬라이드 16] CODE LAB 02 - 수신 및 분류
IMAP 라이브러리를 활용한 메일 수집과 정규식 기반 의도 분류 로직을 구현해보겠습니다.

처리 프로세스는 다섯 단계로 진행돼요. 첫째, SSL 보안 연결로 IMAP 서버에 접속합니다. 둘째, 'UNSEEN' 플래그로 미확인 메일을 검색하죠. 셋째, 헤더와 본문을 파싱하는데 Multipart 디코딩 처리가 필요해요. 넷째, 인텐트 분류 함수로 제목과 본문의 키워드를 매칭합니다. 다섯째, 분류된 결과를 저장하는 거죠.

코드를 함께 살펴볼게요. 먼저 환경변수를 불러오고 분류 함수를 정의합니다. classify 함수는 제목과 본문을 소문자로 변환한 후 키워드를 찾아요.

분류 규칙은 네 가지예요. '문의'라는 키워드가 있으면 'inquiry'로 분류하고요, '결재'나 '승인'이 있으면 'approval'이죠. '면담', '미팅', '일정' 같은 단어는 정규식으로 검색해서 'schedule'로 분류합니다. 매칭되는 게 없으면 'other'로 처리해요.

IMAP 서버에 연결해서 로그인하고 INBOX를 선택합니다. 안 읽은 메일을 검색한 후 최대 10개까지만 가져와요. 각 메일의 제목을 디코딩하고 본문을 추출하는데, multipart 형식인 경우 text/plain 파트만 추출하죠. 마지막으로 인텐트를 분류해서 메시지 리스트에 추가하는 겁니다.

[슬라이드 17] CODE LAB 02 - 응답 생성 및 발송
분류된 인텐트에 따라 적절한 템플릿을 선택하고 SMTP를 통해 회신을 발송하는 실습입니다.

첫 번째 파트는 응답 메시지 생성 함수예요. build_reply 함수를 정의하는데, EmailMessage 객체를 생성하고 제목에는 '[Auto]' 접두사를 붙입니다. From과 To 헤더를 설정하죠.

인텐트별 응답 템플릿을 딕셔너리로 정의해요. 'inquiry'면 "문의 감사합니다. 담당자가 확인 후 24시간 내 회신드리겠습니다"라고 답하고요, 'approval'은 "요청하신 건이 접수되었습니다", 'schedule'은 "일정 제안 감사합니다" 식으로 매핑합니다. 'other'는 기본 템플릿을 사용하죠.

두 번째 파트는 SMTP 발송 실행이에요. SMTP 서버에 연결하고 starttls로 TLS 암호화를 적용합니다. 로그인한 후 build_reply로 생성한 메시지를 send_message로 전송하는 거죠.

발송 전 체크리스트 세 가지 꼭 확인하세요. 첫째, 화이트리스트를 적용해서 테스트 단계에서는 허용된 이메일 주소로만 발송하세요. 둘째, 무한 루프 방지를 위해 상대방도 자동 응답기일 경우 특정 헤더나 내용을 필터링해야 해요. 셋째, 구현 로직이 탄탄한지 재확인하세요.

[슬라이드 18] CODE LAB 03 - 스케줄링과 로깅
주기적인 이메일 수신 확인을 위한 스케줄러 구현과 운영 모니터링을 위한 로깅 설정 실습입니다.

핵심 구현 목표는 두 가지예요. 첫째, 주기적 실행인 Polling이죠. schedule 라이브러리를 사용해서 2분 간격으로 메일함 검사 작업을 수행합니다.

둘째는 로깅이에요. print 대신 logging 모듈을 사용해서 실행 시간, 레벨, 메시지를 표준화된 포맷으로 기록하는 거죠.

코드를 보시면 먼저 로깅 설정을 해요. level은 INFO로 하고 format은 시간과 레벨, 메시지를 포함하도록 정의합니다. job 함수 안에서 로그를 남기고요, 실제로는 receive_email, classify, send_reply 함수들을 호출해야 하죠.

schedule.every(2).minutes.do(job)으로 2분마다 실행되도록 등록하고요, 무한 루프 안에서 run_pending으로 대기 중인 작업을 실행합니다.

실전 운영 팁도 드릴게요. 데몬화가 필요해요. 실제 운영 시에는 systemd나 Docker 컨테이너로 백그라운드에서 상시 구동해야 하죠. 재시도 전략도 중요합니다. 네트워크 일시 장애에 대비해서 실패 시 지수 백오프 방식으로 재시도하는 로직을 추가하세요.

터미널 출력을 보시면 2분마다 폴더 스캔과 자동응답이 실행되는 걸 확인하실 수 있어요.

[슬라이드 19] CODE LAB 04 - 안전장치 구현
시스템 오작동을 막는 중복 처리 방지 로직과 휴먼 인 더 루프 설계 실습입니다.

운영 원칙 두 가지를 기억하세요. 첫째, 동일 메시지는 1회만 처리합니다. Message-ID인 UID를 키로 사용해서 중복 발송 사고를 원천 차단하는 거죠.

둘째, 휴먼 인 더 루프예요. 신뢰도가 낮은 인텐트인 'Other'나 민감 키워드가 포함된 경우 발송을 보류하는 겁니다.

로직 흐름은 네 단계로 진행돼요. 첫째, 수신 메시지의 UID를 조회합니다. 둘째, DB에서 중복 여부를 체크하죠. 셋째, 인텐트를 분류하고 정책 필터링을 적용해요. 넷째, 발송하거나 담당자에게 알림을 보냅니다.

코드를 보시면 shelve 모듈로 파일 기반 DB를 열어요. 실제 환경에서는 Redis나 SQL 같은 DB를 사용하는 게 권장됩니다. is_processed 함수로 이미 처리된 메시지인지 확인하고요, 처리됐으면 스킵하죠.

인텐트가 'other'인 경우에는 "검토 요청"이라고 출력하고 계속하지 않아요. 여기에 Slack 알림이나 검토 큐 적재 로직을 추가하시면 됩니다. 정상 발송되면 DB에 처리 완료 기록을 남기는 거죠.

[슬라이드 20] Section 04 학습 목표
네 번째 섹션인 '메신저 자동 응답 시스템'으로 넘어가겠습니다. 즉각적인 소통이 핵심인 메신저 환경에서의 자동화 전략을 다룰 거예요.

Slack이나 Teams 같은 주요 협업 도구의 특성을 이해하고요, 이벤트 기반 봇을 직접 구현해서 실시간 대응 체계를 구축하는 게 목표입니다.

첫 번째 학습 목표는 채널 특성과 권한 모델 이해예요. 메신저마다 고유한 특성과 권한 체계가 있거든요.

두 번째는 Slack 봇으로 이벤트 처리 PoC를 구현하는 실습입니다. 실제로 작동하는 봇을 만들어볼 거예요.

세 번째는 예외 처리와 레이트 리밋 대응이죠. 안정적인 운영을 위해 필수적인 부분입니다.

[슬라이드 21] 채널별 특성 비교
조직 내부 소통 중심의 협업 도구와 대고객 접점 확보에 유리한 메신저 채널의 특성을 비교해보겠습니다.

먼저 Slack과 Teams 같은 내부 협업 도구의 장점이에요. 첫째는 조직 통합과 권한 관리죠. 사내 조직도와 연동되어 부서별, 직급별 접근 제어가 용이하고요, 강력한 감사 로그 기능을 제공해서 보안 컴플라이언스 준수에 최적화되어 있습니다.

둘째는 풍부한 앱 생태계예요. Jira, GitHub 같은 업무용 SaaS 도구와의 연동성이 뛰어나고요, 블록 킷 같은 걸 활용해서 정교한 인터랙티브 UI를 구성할 수 있어요.

반면 Kakao나 Telegram 같은 대외 메신저의 장점도 있죠. 첫째는 높은 사용자 도달성입니다. 별도 앱 설치 없이 전 국민이 사용하는 메신저를 통해 접근하니까 알림톡, 챗봇 등 대외 커뮤니케이션과 마케팅 채널로 효과적이에요.

둘째는 모바일 중심 UX예요. 모바일 환경에 최적화된 사용자 경험을 제공하고요, 퀵 리플라이 버튼 같은 걸로 간편한 상호작용을 유도하기 유리합니다.

[슬라이드 22] 메신저 아키텍처와 권한 흐름
메신저 시스템의 이벤트 처리 흐름과 권한 및 운영 전략을 살펴보겠습니다.

이벤트 처리는 두 단계로 진행돼요. 첫 단계는 이벤트 수신이에요. Slack이나 Teams 서버로부터 Webhook을 통해 JSON 페이로드를 받습니다.

두 번째 단계는 인증과 서명 검증이죠. Signing Secret을 사용해서 요청이 진짜 Slack에서 온 건지 검증하는 거예요.

권한 및 운영 전략에서 가장 중요한 건 최소 권한 원칙입니다. Scopes를 최소한으로 설정해야 하는데요, 필수 권한만 세 가지 정도면 충분해요. app_mentions:read로 멘션을 읽고, chat:write로 메시지를 쓰며, channels:history로 컨텍스트를 파악하는 거죠.

[슬라이드 23~26] 메신저 실습 코드랩
이제 Slack 봇 구현 실습으로 들어가는데요, 시간 관계상 핵심만 간략히 짚고 넘어가겠습니다.

CODE LAB 05에서는 Slack App을 생성하고 Signing Secret과 Bot Token을 설정합니다. slack_bolt 프레임워크를 사용해서 @app.event와 @app.message 데코레이터로 이벤트를 처리하는 기본 구조를 배우죠.

정규식을 활용한 FAQ 봇 로직도 구현해봅니다. 특정 키워드에 자동으로 반응하는 시뮬레이션이에요.

안정성 확보를 위한 레이트 리밋 대응도 중요합니다. 429 에러가 발생하면 지수 백오프 방식으로 재시도하는 로직을 추가하는 거죠.

[슬라이드 27] Section 05 학습 목표
다섯 번째 섹션인 '자동 응답 정책 수립'으로 넘어갑니다. 기술 구현만큼 중요한 게 바로 운영 정책이에요.

범위, 수준, 톤앤매너 등 실제 운영에 필요한 가이드라인을 정립하는 시간입니다.

[슬라이드 28~31] 정책 프레임워크
정책 프레임워크는 Level 1 완전 자동과 Level 2 핸드오버로 구분됩니다. R&R, 즉 역할과 책임을 명확히 정의해야 하죠.

톤앤매너 가이드의 3대 핵심 원칙은 공손함, 간결함, 일관성입니다. 금지 사항도 명확히 해야 하는데요, 단정적 확답이나 비격식 표현은 피해야 해요.

보안과 컴플라이언스도 체크리스트로 관리합니다. 비식별화, Vault 키 관리, 접근 로그 감사가 포함되죠.

운영 및 개선 사이클은 SLO 지표를 관리하고 주간 운영 리포트 프로세스를 통해 지속적으로 개선하는 구조예요.

[슬라이드 32~33] 실전 프로젝트
여섯 번째 섹션에서는 PoC에서 운영 전환까지의 로드맵을 제시합니다.

실제 학사지원팀 FAQ 케이스 스터디를 분석하고요, 세 가지 실습 미션을 드려요. 새로운 인텐트 추가하기, 템플릿 개선하기, KPI 설정하기입니다.

[슬라이드 34] 핵심 요약 및 Q&A
오늘 배운 내용을 정리하면서 마무리하겠습니다.

첫째, 하이브리드 전략을 기억하세요. 규칙 기반과 LLM을 적절히 조합하는 게 핵심입니다.

둘째, 안전장치를 반드시 구축하세요. 중복 방지, 휴먼 인 더 루프, 레이트 리밋 대응이 필수예요.

셋째, 정책을 우선시하세요. 기술보다 운영 정책이 성패를 좌우합니다.

궁금하신 점이 있으시면 정보전산원으로 연락 주시고요, 오늘 교육이 여러분의 업무 자동화에 실질적인 도움이 되길 바랍니다. 감사합니다.
