
안녕하세요, 여러분. 국립창원대학교 PRU 재직자 교육 과정에 오신 것을 환영합니다. 오늘은 Multi-에이전트 협업 개념 이해라는 주제로 함께 공부하겠습니다.
오늘 강의는 4개 파트로 구성되어 있습니다. Part 0는 도입부로 강의 소개와 학습 목표를 설정하고, Part 1에서는 Multi-에이전트 기초 이론을 다룹니다. 개념부터 핵심 구성요소, 그리고 주요 프레임워크 비교까지 살펴볼 거예요. Part 2는 역할별 분업 구조입니다. 역할 정의의 중요성과 작성-검수 에이전트 패턴을 실습과 함께 배우죠. Part 3에서는 복잡한 작업의 단계적 자동화, 즉 워크플로우 오케스트레이션을 실습하고, Part 4에서 종합 및 마무리로 실전 적용 가이드와 Q&A 시간을 갖겠습니다.

이번 과정을 통해 달성하고자 하는 핵심 역량과 이해도를 명확히 해볼까요?
첫 번째 목표는 Multi-에이전트 개념 이해입니다. 단일 에이전트와의 차이점을 이해하고, 협업 메커니즘과 주요 프레임워크인 LangChain, CrewAI의 특성을 파악하는 거죠.
두 번째는 역할 분업 구조 설계입니다. 작성자-검수자 등 역할별 에이전트를 정의하고, 효율적인 업무 위임과 협업 패턴을 설계하고 구현하는 능력을 키웁니다.
세 번째는 단계적 자동화 구현이에요. 복잡한 작업을 세부 단계로 분해하고, Workflow Orchestration을 통해 자동화 파이프라인을 완성하는 실습까지 진행할 예정입니다.

본격적으로 Part 1, Multi-에이전트 기초 이론으로 들어가겠습니다. 먼저 에이아이 에이전트가 무엇인지부터 정의해야겠죠?
에이아이 에이전트는 LLM, 즉 Large Language Model의 추론 능력을 활용해서 자율적으로 계획을 수립하고 도구를 사용하여 목표를 달성하는 시스템입니다. 중심에는 LLM Brain이 있고, 그 주변으로 Planning, Memory, Tools, Action이 결합되어 있어요.
핵심 특징을 보면, 첫째로 목표 지향적입니다. 단순 응답이 아니라 주어진 목표 달성을 위해 행동하죠. 둘째, 도구 사용 능력이 있습니다. 검색, 계산기, API 등 외부 도구를 스스로 선택하고 실행해요. 셋째, 추론 및 계획 능력이에요. 작업을 단계별로 분해하고 실행 계획을 수립하는 Chain-of-Thought 방식을 사용합니다. 넷째, 메모리를 가지고 있어요. 과거의 행동과 결과를 기억하고 문맥을 유지하죠.
대표적인 에이전트 예시를 보면, Researcher 에이전트는 웹 검색을 통해 최신 정보를 수집하고 요약합니다. Coding 에이전트는 요구사항에 맞춰 코드를 작성하고 실행해서 디버깅하죠. Data Analyst 에이전트는 CSV 데이터를 분석하고 시각화 차트를 생성합니다.

단일 에이전트와 다중 에이전트 시스템의 구조적 차이를 비교해볼까요?
Single 에이전트, 단일 에이전트의 장점은 단순한 구조와 구현이에요. 관리와 디버깅이 용이하죠. 하지만 단점도 명확합니다. 복잡한 과제 수행에 한계가 있고, 순차적 처리로 인한 병목이 발생해요.
반면 Multi-에이전트, 다중 에이전트 시스템은 전문 역할 분업과 협업이 가능합니다. 병렬 처리와 확장성이 뛰어나고, 상호 검증을 통해 품질을 향상시킬 수 있죠. 단점은 높은 조율과 통신의 복잡도입니다.

그렇다면 왜 Multi-에이전트가 필요한지, 네 가지 이유를 살펴보겠습니다.
첫 번째는 전문성 분리입니다. 복잡한 문제를 작은 단위로 분해해서 각 에이전트가 특정 도메인, 예를 들어 검색이나 코드 작성, 요약 같은 영역에 집중함으로써 결과물의 깊이와 전문성을 확보할 수 있어요.
두 번째는 품질 향상, Quality Assurance입니다. 작성자인 Writer와 검수자인 Reviewer 역할을 분리해서 상호 검증, 즉 Cross-check을 수행하면 LLM의 환각 현상을 줄이고 정확도를 높일 수 있죠.
세 번째는 확장성입니다. 독립적인 에이전트들이 작업을 병렬로 처리할 수 있어서 작업량이 증가하더라도 효율적인 리소스 관리와 처리 속도를 유지할 수 있어요.
네 번째는 복원력, Resilience입니다. 특정 단계에서 에러가 발생하더라도 전체 프로세스를 중단하지 않고, 재시도하거나 대체 경로인 Fallback을 통해 작업을 완수할 수 있습니다.
결국 Multi-에이전트는 단일 에이전트의 한계, 즉 컨텍스트 길이 제한이나 복합 추론 오류를 구조적으로 해결하는 방법이에요.

Multi-에이전트 시스템의 7가지 핵심 구성요소를 살펴보겠습니다.
첫 번째, 역할입니다. 에이전트의 정체성과 책임을 정의하죠. Researcher, Editor, Manager 같은 명확한 역할 정의가 협업의 기초예요.
두 번째, 목표입니다. 에이전트가 달성해야 할 구체적인 성과를 의미하고, 행동의 방향성을 결정하며 완료 기준을 제공합니다.
세 번째, 지식과 메모리입니다. 도메인 지식인 Backstory와 대화 기록인 Short/Long-term Memory를 통해 일관된 맥락을 유지해요.
네 번째, 도구입니다. 외부 세계와 상호작용하는 수단이죠. 검색 API, 코드 실행기, 파일 리더 등이 에이전트의 능력을 확장합니다.
다섯 번째, 의사소통입니다. 에이전트 간 정보 교환 방식이에요. 메시지 패싱, 공유 상태인 State, 툴 호출 등을 통해 협업하죠.
여섯 번째, 오케스트레이션입니다. 작업 흐름을 제어하는 관리자 역할로, 순차, 병렬, 계층적 구조를 통해 에이전트들을 조율합니다.
일곱 번째, 관찰과 평가입니다. 실행 과정을 추적하고 품질을 측정해서 시스템의 신뢰성을 확보하고 디버깅을 돕는 거예요.
이 7가지 요소가 통합된 시스템이 바로 Multi-에이전트 시스템입니다.

협업 메커니즘을 통신, 조율, 협력의 3단계로 나눠서 이해해보겠습니다.
첫 번째 단계는 통신, Communication입니다. 에이전트 간 정보와 상태를 교환하는 가장 기초적인 단계예요. 메시지 전달인 Message Passing, 공유 상태인 Shared State, 도구 호출인 Tool Calls 방식이 있습니다.
두 번째는 조율, Coordination입니다. 작업의 순서와 흐름을 제어해서 충돌을 방지하고 효율을 높이는 거죠. 순차 실행인 Sequential, 병렬 처리인 Parallel, 계층 구조인 Hierarchical 방식으로 나뉩니다.
세 번째는 협력, Collaboration입니다. 공동의 목표 달성을 위해 적극적으로 상호작용하고 합의를 도출해요. 작업 위임인 Delegation, 상호 질의인 Ask Questions, 토론 및 합의인 Debate 방식이 있죠.

Multi-에이전트를 구현할 수 있는 주요 프레임워크 세 가지를 소개하겠습니다.
첫 번째는 LangChain과 LangGraph입니다. 그래프 기반 워크플로우 제어 방식이에요. 커스텀 워크플로우를 그래프, 즉 Node와 Edge 구조로 복잡한 흐름을 설계할 수 있고, 상태 공유를 통해 에이전트 간 메모리와 컨텍스트를 쉽게 공유할 수 있습니다. 휴먼 인 더 루프, 즉 사용자 개입도 손쉽게 통합할 수 있죠. 복잡한 엔터프라이즈 로직에 최적입니다.
두 번째는 AutoGen입니다. 대화형 멀티 에이전트 프레임워크예요. 대화형 패턴으로 에이전트 간 채팅을 통한 자연스러운 협업이 가능하고, 강력한 코드 생성과 실행 환경을 제공합니다. 제어력이 뛰어나서 루프나 조건 분기 등 세밀한 제어가 가능하죠. 코딩과 대화형 문제 해결에 적합합니다.
세 번째는 CrewAI입니다. 역할 기반의 팀 협업 구조예요. 역할, 목표, 배경을 직관적으로 설정할 수 있고, 자동 위임 기능으로 에이전트 간 자율적인 업무 위임을 지원합니다. LangChain 통합도 가능해서 도구 생태계를 활용할 수 있죠. 팀 단위 역할 분담 구조에 최적입니다.

세 가지 프레임워크를 구체적으로 비교해보겠습니다.
통신 방식을 보면, LangGraph는 Graph State, 즉 공유 상태 객체를 통한 데이터 전달 방식입니다. AutoGen은 메시지 교환, Conversable 구조로 대화형 메시지 패싱이에요. CrewAI는 위임과 질의, Delegation 방식으로 역할 기반 작업 위임과 정보 공유를 사용하죠.
제어 흐름을 보면, LangGraph는 유연한 그래프 구조로 순환이나 분기 등 커스텀 로직 설계가 강력합니다. AutoGen은 대화 패턴 기반으로 Group Chat이나 1대1 대화 등을 패턴화했고, CrewAI는 팀 프로세스로 순차적이거나 매니저 주도의 계층 구조를 제공해요.
툴 통합은 LangGraph가 광범위한 생태계로 LangChain의 모든 툴과 리트리버를 활용할 수 있습니다. AutoGen은 코드 실행에 특화되어 Docker 컨테이너 내 코드 실행이 강력하고, CrewAI는 LangChain 툴을 래핑해서 사용하기 용이해요.
관측성 측면에서는 LangGraph가 LangSmith 통합으로 최적화되어 모든 단계의 상세한 트레이싱과 디버깅이 가능합니다. AutoGen은 기본 로깅을 제공하지만 외부 도구 연동이 필요하고, CrewAI는 에이전트Ops 등과 연동해서 Step Callback을 통한 모니터링을 지원하죠.
Key Takeaway는, 정교한 제어와 상태 관리가 필요하면 LangGraph, 팀 역할 기반의 직관적 구성은 CrewAI, 코드 중심의 자율적 해결은 AutoGen이 유리하다는 점입니다.

Part 1을 정리하겠습니다. 성공적인 Multi-에이전트 시스템은 명확한 역할 정의와 오케스트레이션이 좌우합니다.
구조 설계, Structure가 중요합니다. 단일 에이전트의 한계를 극복하기 위해 전문화된 역할을 정의하고, 이들 간의 효율적인 협업 구조를 설계해야 해요.
소통 방식, Communication도 핵심입니다. 단순 메시지 교환을 넘어서 공유 상태와 명확한 핸드오프 규칙을 통해 문맥 손실을 최소화해야 하죠.
도구 선택, Framework도 전략적으로 접근해야 합니다. 유연성이 필요하면 LangGraph, 팀 협업 패턴은 CrewAI, 대화형 구조는 AutoGen 등 목적에 맞는 프레임워크를 선택해야 해요.

이제 Part 2로 넘어갑니다. 역할별 분업 구조를 다루는데요, 작성자, 검수자, 관리자 등 명확한 역할 정의를 통해 생산성을 극대화하고 에러를 최소화하는 협업 패턴을 학습하겠습니다.

성공적인 Multi-에이전트 시스템은 각 에이전트의 명확한 역할과 책임, 그리고 상호작용 규칙에 달려 있습니다.
Bad Case를 보면 역할 중복과 책임이 모호한 상황이에요. A와 B가 서로 물음표를 던지는 구조죠. Good Case는 명확한 분업과 데이터 흐름이 정의되어 있습니다. A에서 B로 json 형식으로 명확하게 전달되는 거예요.
세 가지 원칙을 기억하세요. 첫째, 명확한 경계 설정입니다. 에이전트가 해야 할 일과 하지 말아야 할 일을 명확히 구분해서 충돌과 중복을 방지해야 해요.
둘째, 핸드오프 규칙입니다. 작업이 완료된 시점과 다음 에이전트로 작업을 넘기는 조건 및 방식을 구체적으로 정의해야 하죠.
셋째, 출력 포맷 표준화입니다. json이나 Markdown 등 구조화된 포맷을 사용해서 다음 단계 에이전트의 파싱 오류를 최소화하는 거예요.
역할 정의 프롬프트 예시를 보면, Bad는 "글을 잘 써줘"처럼 모호합니다. Good은 "당신은 전문 테크 에디터입니다. 작성자가 보낸 초안을 검토해서 1) 맞춤법 교정, 2) 논리적 비약 수정, 3) 톤앤매너 일치 여부를 확인하세요. 결과는 수정된 본문과 변경 사유를 포함한 json 형식으로 출력해야 합니다"처럼 구체적이죠.

가장 기본적이고 효과적인 Multi-에이전트 협업 패턴인 Writer와 Reviewer 패턴을 살펴보겠습니다.
생성과 비평 역할을 분리해서 결과물의 품질을 극대화하는 전략이에요. 입력으로 요구사항과 주제가 전달되면, Writer 에이전트가 초안을 작성합니다. 그 다음 Reviewer 에이전트가 품질을 검수하고 피드백을 제공하죠. Writer가 다시 피드백을 반영해서 수정하고, Reviewer가 최종 승인하면 결과물이 도출되는 구조입니다.
Writer의 역할은 주어진 주제와 요구사항에 맞춰 창의적인 초안을 작성하는 거예요. 방대한 정보를 구조화하고 문맥을 생성하는 데 집중하죠.
Reviewer의 역할은 초안을 비판적으로 분석해서 오류, 편향, 논리적 결함을 식별하는 겁니다. 구체적인 개선 피드백을 제공하고요.
반복적 개선, Iterative Refinement를 통해 피드백 루프로 결과물을 점진적으로 개선합니다. 합격 기준을 충족할 때까지 수정 과정을 반복하는 거죠.
핵심 이점은 품질 향상, 환각 감소, 객관성 확보, 논리적 일관성입니다.

Writer-Reviewer Loop를 시각화한 다이어그램입니다.
Writer 에이전트가 주제에 맞는 초안을 작성하는 Initial Content Generation 단계가 있고, Reviewer 에이전트가 정확성, 스타일, 정책을 검수하는 Critique & Validation 단계가 이어집니다. OK가 나오면 최종 결과물이 생성되지만, 아니면 다시 Writer에게 피드백이 돌아가는 피드백 루프, Iterative Loop가 형성되죠.
작성, 검수, 피드백 루프의 3단계 구조입니다.

실습 1번을 진행해보겠습니다. LangChain을 사용해서 주제에 맞는 고품질 블로그 포스트를 생성하고, 자동화된 검수 과정을 통해 내용을 검증하고 개선하는 실습이에요.
입력은 json 형식으로 topic이 "AI Trends"이고 target이 "Developers"입니다. 출력은 Markdown 형식의 최종 블로그 포스트로 약 1000자 분량이죠.
실행 결과 분석을 보면, 10시 5분 22초에 시스템이 워크플로우를 초기화하고, Writer가 초안 작성을 시작해서 5초 후에 850자 길이의 초안을 생성했습니다. Reviewer가 품질 보증을 위해 분석을 시작하고, 2개의 문제를 발견했어요. 첫째는 서론에 명확한 정의가 부족하고, 둘째는 섹션 3에 코드 예시가 필요하다는 피드백이죠.
Writer가 피드백을 기반으로 내용을 수정해서 정의와 Python 코드 스니펫을 추가했고, Reviewer가 품질 검사를 통과시켜서 9.5점 만점에 10점을 받았습니다. 최종 결과물이 output/blog_post.md에 저장되고 프로세스가 성공적으로 완료됐어요.
평가 지표는 사실성, 즉 허위 정보 포함 여부, 구조, 즉 서론-본론-결론의 논리적 흐름, 가독성, 즉 타겟 독자에 적합한 용어 사용입니다.

세 가지 협업 패턴을 비교해보겠습니다.
Manager-Worker는 중앙 집중형입니다. 매니저가 작업을 작은 단위로 분해해서 워커들에게 할당하고 결과를 취합하죠. 복잡한 작업의 효율적 분업, 명확한 책임 소재와 제어, 병렬 처리를 통한 속도 향상이 장점입니다.
Peer-to-Peer는 자율 협력형입니다. 중앙 관리자 없이 에이전트들이 서로 정보를 교환하고 토론해서 결론을 도출해요. 다양한 관점의 통합, 상호 검증을 통한 환각 감소, 유연한 문제 해결 방식이 장점이죠.
Hierarchical은 대규모 조직형입니다. 중간 관리자가 존재해서 상위 목표를 하위 팀에게 전달하고 관리하는 복합 구조예요. 대규모 프로젝트의 확장성, 도메인별 전문성 심화, 체계적인 정보 흐름 관리가 장점입니다.

실습 2번은 CrewAI로 다중 역할 시스템을 구현하는 겁니다. Researcher, Writer, Editor 협업 구조와 allow_delegation 활용을 배워요.
코드를 보면, 먼저 역할별 에이전트를 정의합니다. Researcher는 'Senior Research Analyst' 역할로, 최신 AI 기술 동향에 대한 심층 분석을 수행하는 게 목표예요. backstory는 데이터에 기반한 정확한 정보를 찾는 수석 연구원이고, allow_delegation은 False입니다. 스스로 작업을 수행하죠.
Writer는 'Tech Content Writer' 역할로, 분석된 내용을 바탕으로 매력적인 블로그 글을 작성하는 게 목표예요. backstory는 복잡한 기술 개념을 대중이 이해하기 쉽게 풀어쓰는 작가이고, allow_delegation은 True입니다. 중요한 건 리서처에게 질문하거나 위임할 수 있다는 거죠.
Editor는 'Chief Editor' 역할로, 콘텐츠의 논리적 흐름과 품질을 보증하는 게 목표이고, allow_delegation은 True로 작가에게 수정 요청이 가능해요.
태스크를 정의하면, task1은 2025년 생성형 AI 에이전트 트렌드 조사로 Researcher가 담당하고, task2는 조사 결과를 바탕으로 1500자 내외의 블로그 초안을 Writer가 작성하며, task3는 초안의 문체 교정 및 기술적 정확성을 Editor가 최종 검토합니다.
크루를 구성해서 Process.sequential로 순차적 실행 모드를 설정하고, kickoff로 실행하죠.
핵심 구현 포인트는 세 가지입니다. 역할 분리, 협업 허용, 순차 프로세스예요. 데이터 흐름은 Researcher가 정보 수집 및 정리를 하고, Writer가 초안을 작성하며 필요시 Delegation으로 Researcher에게 질의할 수 있고, Editor가 최종 검수와 윤문을 담당합니다.

실행 결과와 로그 분석을 보겠습니다.
14시 20분 10초에 CrewAI가 Hierarchical 프로세스로 초기화됐고, Writer가 Multi-에이전트 Systems에 대한 기사 작성 작업을 시작했습니다. Writer가 Researcher에게 AI 도입에 대한 최신 통계를 찾아달라고 작업을 위임했죠. Research가 인터넷을 검색해서 "65%의 기업이 GenAI를 테스트 중"이라는 데이터를 찾아서 Writer에게 결과를 다시 보냈습니다.
Writer가 검색된 통계를 포함해서 기사 초안을 작성하고, 검토를 위해 제출했어요. Editor가 기사의 톤과 명확성을 검토해서 "super cool"을 "highly innovative"로 수정하는 교정을 했고, 최종 결과물인 article_final.md가 생성됐습니다.
로그 분석 관찰에서 보면, Writer가 Researcher에게 Ask Question 도구를 사용해서 통계 데이터를 요청하고, Editor가 최종 검수하는 위임 패턴이 성공적으로 실행됐어요.
기대 결과는 초안에 최신 AI 트렌드와 통계 데이터가 포함된 본문이고, 편집본은 톤앤매너가 일관되고 오타가 수정된 최종 기사입니다.
모범 사례로는 Role-Playing, 즉 각 에이전트의 backstory를 구체적으로 설정하는 것과, Delegation, 즉 allow_delegation을 True로 설정해서 에이전트 간 협업을 유도하는 것입니다.

Part 2를 정리하겠습니다. 역할별 분업 구조 설계를 위한 4가지 핵심 베스트 프랙티스입니다.
첫째, 역할 중복 회피입니다. 에이전트 간 역할과 책임 범위를 명확히 정의해서 업무 중복과 충돌을 방지하고 전문성을 극대화해야 해요.
둘째, 위임 권한 설계입니다. 모든 에이전트가 아닌 코디네이터나 매니저 역할에만 위임 권한을 부여해서 무한 루프와 복잡도를 제어하죠.
셋째, 컨텍스트 전달입니다. 다음 단계 에이전트에게 필요한 문맥 정보, 즉 이전 결과나 제약 조건을 명시적으로 전달하는 표준 포맷을 정의해야 합니다.
넷째, 체크리스트 검수입니다. 검수 에이전트는 막연한 '검토'가 아니라 구체적인 항목이 명시된 체크리스트를 기반으로 품질을 검증해야 해요.

Part 3으로 넘어갑니다. 복잡한 작업의 단계적 자동화를 다루는데요, 단일 에이전트의 한계를 넘어서 복잡한 비즈니스 로직을 처리하기 위한 워크플로우 오케스트레이션과 단계적 실행 전략을 배우겠습니다.

Workflow Orchestration이란 다수의 AI 에이전트와 도구들이 복잡한 작업을 수행하기 위해 상호작용하는 흐름을 정의하고, 실행 상태를 관리하며, 제어하는 프로세스입니다.
네 가지 핵심 요소가 있습니다. 첫째, State, 즉 상태입니다. 워크플로우 전체에서 공유되는 메모리 스키마예요. 에이전트 간에 주고받는 메시지, 작업 결과, 컨텍스트 데이터를 유지 관리하죠.
둘째, Node, 즉 노드입니다. 실질적인 작업을 수행하는 단위예요. LLM 호출, 도구 실행, 데이터 처리 함수 등이 노드로 정의되어 실행됩니다.
셋째, Edge, 즉 간선입니다. 노드와 노드 사이를 연결하는 제어 흐름이죠. 조건부 분기인 Conditional Edge를 통해 작업 결과에 따라 다음 단계를 동적으로 결정해요.
넷째, Checkpoint, 즉 체크포인트입니다. 워크플로우의 각 단계별 상태를 저장하는 Persistence 기능이에요. 에러 발생 시 복구하거나, 사람의 승인인 HitL을 기다릴 때 사용하죠.
LangGraph 같은 최신 프레임워크는 그래프 이론을 기반으로 이 4가지 요소를 구현합니다.

Sequential, Parallel, Hierarchical 워크플로우의 특징과 선택 기준을 비교해보겠습니다.
Sequential, 순차형은 구조가 단순하고 예측 가능합니다. 디버깅과 에러 추적이 용이하죠. 단점은 단계별 지연 시간이 누적된다는 거예요. 강한 의존성이 있을 때, 즉 A에서 B로 순서가 중요한 경우에 적합합니다.
Parallel, 병렬형은 높은 처리량과 전체 실행 시간 단축이 장점입니다. 단점은 경합 상태와 병합이 복잡하다는 거죠. 독립적인 하위 작업들을 처리할 때 최적입니다.
Hierarchical, 계층형은 모듈화와 책임 분리, 대규모 시스템 확장성이 장점입니다. 단점은 설계와 관리 난이도가 높다는 거예요. 복잡한 대규모 과제에 적합하죠.

네 가지 워크플로우 패턴을 시각화해서 보겠습니다.
팬아웃/팬인, Fan-Out/Fan-In은 작업을 병렬로 분산 실행하는 Map 단계와, 결과를 하나로 취합하는 Reduce 단계로 구성됩니다. 대규모 문서 요약이나 다각도 리서치 종합에 사용하죠.
매니저-워커, Manager-Worker는 중앙 관리자가 작업을 계획하고 하위 에이전트에게 할당 및 감독하는 계층 구조예요. 복잡한 프로젝트 계획 수립과 실행 관리에 적합합니다.
이벤트 기반 분기, Event-Driven은 조건이나 외부 이벤트에 따라 실행 경로를 동적으로 선택하는 유연한 흐름입니다. 사용자 입력 유형에 따른 맞춤형 응대 처리에 사용해요.
회복 루프, Recovery Loop는 실패나 품질 미달 시 자동으로 이전 단계로 돌아가 재시도하거나 수정하는 루프입니다. 코드 생성 오류 수정이나 문서 품질 검수 반복에 활용하죠.

실습 3번입니다. LangGraph로 워크플로우를 정의하는 실습이에요.
코드를 보면, 먼저 State를 정의합니다. 에이전트State라는 TypedDict로 task, draft, review_score, revision_count, messages 같은 공유 상태 스키마를 만들어요.
Graph를 초기화해서 StateGraph로 워크플로우를 만들고, Node를 추가합니다. researcher, writer, reviewer 노드를 각각 research_node, write_node, review_node 함수로 연결하죠.
Edge와 조건부 분기를 설정합니다. entry_point를 researcher로 설정하고, researcher에서 writer로, writer에서 reviewer로 간선을 추가해요. should_continue 함수를 정의해서, review_score가 80점 이상이거나 revision_count가 3회를 초과하면 END를 반환하고, 아니면 writer로 다시 돌아가는 루프를 형성합니다.
마지막으로 컴파일 단계에서 MemorySaver로 체크포인트를 활성화해서 상태 지속성을 확보하죠.
구조 정의 포인트는 네 가지입니다. State는 에이전트 간 공유되는 데이터 스키마를 TypedDict로 활용하고, Nodes는 실제 작업을 수행하는 함수나 에이전트 단위예요. Edges는 실행 순서를 정의하고 conditional_edges로 동적 흐름을 제어하며, Checkpoint는 MemorySaver를 통해 상태 지속성과 Time Travel을 가능하게 합니다.
Tip은 should_continue 함수가 오케스트레이션 로직의 핵심이라는 점입니다. 점수가 낮으면 작성 단계로 되돌아가는 Self-Correction 루프를 형성하죠.

에이전트 구현 및 워크플로우 실행 코드입니다.
먼저 모델을 초기화하고 도구를 바인딩합니다. ChatOpenAI로 gpt-4o 모델을 temperature 0으로 설정하고, web_search와 report_writer 같은 툴 목록을 만들어서 llm.bind_tools로 모델에 연결해요. 이렇게 하면 LLM이 필요 시 스스로 도구 호출을 결정할 수 있습니다.
Checkpointer는 MemorySaver를 통해 그래프의 실행 상태를 영구적으로 저장하죠. 멀티턴 대화나 에러 복구가 가능해집니다.

LangGraph 실행 로그를 통해 처리 시간, 정확도, 에러 핸들링 지표를 확인할 수 있습니다. 각 노드의 실행 시간과 상태 변화를 추적해서 병목 구간을 식별하고, 조건부 분기가 올바르게 작동하는지 검증할 수 있어요.

복잡한 목표를 하위 과제로 분해하고 동적으로 재계획하는 기법입니다. 큰 작업을 작은 단위로 나눠서 각 에이전트가 전문성을 발휘할 수 있도록 하고, 실행 중간에 상황에 따라 계획을 조정할 수 있는 유연성을 확보하는 거죠.

가드레일, 재시도 전략, 사람의 승인, 실패 격리 기법을 다룹니다.
가드레일은 에이전트가 허용된 범위 내에서만 행동하도록 제한하는 안전장치예요. 재시도 전략은 exponential backoff 같은 방식으로 실패 시 재시도 간격을 늘려가며 최대 횟수까지 재시도하죠.
휴먼 인 더 루프, 즉 Interrupt 기능은 중요한 의사결정 시점에 사람의 승인을 받는 메커니즘입니다. 실패 격리는 한 에이전트의 에러가 전체 시스템으로 전파되지 않도록 격리하는 기법이에요.

Part 3을 정리하겠습니다.
상태 기반 그래프와 관측 가능성의 중요성을 강조합니다. LangGraph의 StateGraph는 복잡한 조건부 흐름과 루프 제어를 가능하게 하고, LangSmith 같은 관측성 도구로 실행 과정을 상세하게 추적해서 디버깅과 최적화를 할 수 있어요.

실전 적용을 위한 설계 원칙입니다.
포맷 표준화는 에이전트 간 데이터 교환을 json이나 Pydantic 모델로 표준화해서 파싱 오류를 최소화하는 거예요. 위임 정책은 무한 루프를 방지하기 위해 위임 깊이를 제한하고, 매니저급 에이전트에만 권한을 부여하죠.
관측성은 LangSmith나 LangFuse로 모든 단계를 트레이싱해서 실시간 모니터링과 사후 분석을 가능하게 합니다. 모델 중립성은 특정 LLM 벤더에 종속되지 않도록 추상화 계층을 유지하는 거예요.

오늘 배운 내용을 종합하겠습니다.
분업 구조는 명확한 역할 정의와 핸드오프 규칙이 품질의 기반입니다. 프레임워크 활용은 목적에 맞는 도구 선택, 즉 LangGraph, CrewAI, AutoGen을 전략적으로 사용하는 거죠. 신뢰성 확보는 체크포인트, 에러 핸들링, 휴먼 인 더 루프로 운영 안정성을 확보하는 것입니다.
이 세 가지 전략을 결합해서 실전에 적용하세요.

마무리하겠습니다. 공식 문서는 LangChain, CrewAI, AutoGen 공식 사이트를 참고하시고, LangSmith로 트레이싱과 디버깅을 실습해보세요. 깃허브 실습 코드 저장소에서 오늘 다룬 예제 코드를 다운로드할 수 있습니다.
질문 있으신 분은 지금 말씀해주세요. 오늘 수고 많으셨습니다!
